<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess User Reviewer</title>
    <style>
        :root {
            --bg-dark: #121212;
            --card-bg: #1e1e1e;
            --primary: #3498db;
            --accent: #e74c3c;
            --warning: #f39c12;
            --success: #2ecc71;
            --excellent: #27ae60;
            --book: #a29bfe;
            --draw: #95a5a6;
            --text: #f5f5f5;
            --subtext: #aaaaaa;
            --progress-bg: #333;
            --border: #333;
            --board-white: #ebecd0;
            --board-black: #779556;
            --highlight: rgba(255, 255, 0, 0.4);
            --user-move-bg: #252a35;
            --opponent-move-bg: #111111;
        }
        body { 
            font-family: 'Inter', sans-serif; 
            background: var(--bg-dark); 
            color: var(--text); 
            margin: 0; 
            padding: 20px;
        }
        .container { max-width: 1100px; margin: auto; }
        
        .controls { 
            background: var(--card-bg); 
            padding: 20px; 
            border-radius: 12px; 
            display: flex; 
            gap: 12px; 
            margin-bottom: 20px; 
            border: 1px solid var(--border);
        }
        input { flex: 1; padding: 14px; border-radius: 8px; border: 1px solid #444; background: #111; color: #fff; }
        button { padding: 14px 28px; border-radius: 8px; border: none; background: var(--primary); color: white; cursor: pointer; font-weight: 700; transition: opacity 0.2s; }
        button:disabled { background: #444; opacity: 0.6; cursor: not-allowed; }
        #btnStop { background: var(--accent); display: none; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
            text-align: center;
        }
        .stat-val { font-size: 24px; font-weight: 800; color: var(--primary); margin-bottom: 5px; }
        .stat-label { font-size: 12px; color: var(--subtext); text-transform: uppercase; letter-spacing: 1px; }

        .status-box { background: #111; padding: 15px; border-radius: 10px; border: 1px solid var(--border); margin-bottom: 20px; }
        #progress-container { display: none; margin-top: 10px; }
        .progress-bar-bg { width: 100%; height: 8px; background: var(--progress-bg); border-radius: 4px; overflow: hidden; }
        #progress-bar-fill { width: 0%; height: 100%; background: var(--primary); transition: width 0.2s; }
        #progress-stats { font-family: monospace; font-size: 11px; line-height: 1.6; color: var(--subtext); margin-bottom: 8px; }

        .game-card { 
            background: var(--card-bg); 
            padding: 20px; 
            border-radius: 12px; 
            border: 1px solid var(--border);
            margin-bottom: 15px;
            cursor: pointer;
        }
        .game-header { display: flex; gap: 15px; align-items: center; }
        .side-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 1px solid #444; }
        .side-icon.white { background: #eee; color: #111; }
        .side-icon.black { background: #111; color: #eee; }

        .analysis-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            display: none;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }
        .game-card.expanded .analysis-container { display: grid; }

        .board-layout {
            display: grid;
            grid-template-columns: 25px 1fr;
            grid-template-rows: 1fr 25px;
            width: 100%;
            max-width: 440px;
            margin: auto;
            position: relative;
        }

        .board-wrapper { 
            grid-column: 2;
            grid-row: 1;
            position: relative; 
            aspect-ratio: 1/1;
            background: #2a2a2a; 
            border-radius: 4px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); 
        }

        .ranks-labels {
            grid-column: 1; grid-row: 1;
            display: flex; flex-direction: column; justify-content: space-around;
            align-items: center; color: #888; font-size: 11px; font-weight: bold; font-family: monospace;
        }
        .files-labels {
            grid-column: 2; grid-row: 2;
            display: flex; justify-content: space-around;
            align-items: center; color: #888; font-size: 11px; font-weight: bold; font-family: monospace;
        }

        .chess-board { 
            display: grid; grid-template-columns: repeat(8, 12.5%); grid-template-rows: repeat(8, 12.5%); 
            width: 100%; height: 100%; border: 2px solid #333; user-select: none; position: relative;
        }
        .square { position: relative; display: flex; align-items: center; justify-content: center; font-size: 32px; }
        .square.white { background: var(--board-white); }
        .square.black { background: var(--board-black); }
        .square.highlight { background-color: var(--highlight) !important; }
        .piece { width: 90%; height: 90%; pointer-events: none; z-index: 2; }

        .arrow-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        .board-controls { margin-top: 25px; display: flex; flex-direction: column; gap: 12px; grid-column: 1 / span 2; }
        .main-eval-bar-container { width: 100%; height: 20px; background: #000; border-radius: 10px; border: 1px solid #444; overflow: hidden; position: relative; }
        .main-eval-bar-fill { height: 100%; background: #fff; transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); width: 50%; }
        .main-eval-text { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; color: #fff; mix-blend-mode: difference; }

        .nav-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .nav-btn { padding: 10px; background: #333; border: 1px solid #444; border-radius: 6px; color: white; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .nav-btn:hover { background: #444; }

        .move-list { height: 550px; overflow-y: auto; background: #000; border-radius: 8px; display: flex; flex-direction: column; }
        
        .move-row {
            display: grid; grid-template-columns: 110px 1fr 65px; align-items: center;
            padding: 10px; border-bottom: 1px solid #222; cursor: pointer; transition: background 0.2s;
        }
        .move-row.user-move { background: var(--user-move-bg); }
        .move-row.opponent-move { background: var(--opponent-move-bg); opacity: 0.8; }
        .move-row:hover { background: #333 !important; }
        .move-row.active { background: #444 !important; outline: 1px solid var(--primary); z-index: 5; }
        
        .move-identity { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; font-weight: bold; }
        .user-id { color: var(--primary); }
        .opponent-id { color: #888; }

        .move-label { font-size: 9px; text-transform: uppercase; font-weight: 900; padding: 2px 4px; border-radius: 3px; width: fit-content; }
        .cls-book { background: var(--book); color: #000; }
        .cls-best { background: var(--success); color: #000; }
        .cls-excellent { background: var(--excellent); color: #fff; }
        .cls-good { background: #34495e; color: #fff; }
        .cls-inaccuracy { background: #f1c40f; color: #000; }
        .cls-mistake { background: var(--warning); color: #fff; }
        .cls-blunder { background: var(--accent); color: #fff; }

        .eval-text { font-family: 'Fira Code', monospace; font-size: 11px; text-align: right; min-width: 50px; }
        .mate-txt { color: #f1c40f; font-weight: bold; }

        @media (max-width: 768px) {
            .analysis-container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>♟️ Chess User Reviewer</h1>
    
    <div class="controls">
        <input type="text" id="username" placeholder="Chess.com Username" onkeyup="if(event.key==='Enter') startAnalysis()">
        <button id="btnScan" onclick="startAnalysis()" disabled>Booting Engine...</button>
        <button id="btnStop" onclick="stopAnalysis()">Stop</button>
    </div>

    <div id="stats-container" class="stats-grid" style="display:none">
        <div class="stat-card">
            <div id="stat-acc" class="stat-val">0%</div>
            <div class="stat-label">Avg Accuracy</div>
        </div>
        <div class="stat-card">
            <div id="stat-blunder" class="stat-val">0</div>
            <div class="stat-label">Total Blunders</div>
        </div>
        <div class="stat-card">
            <div id="stat-great" class="stat-val">0</div>
            <div class="stat-label">Great Moves</div>
        </div>
        <div class="stat-card">
            <div id="stat-opening" class="stat-val">N/A</div>
            <div class="stat-label">Fav Opening</div>
        </div>
        <div class="stat-card">
            <div id="stat-book" class="stat-val">0</div>
            <div class="stat-label">Longest Theory</div>
        </div>
    </div>

    <div class="status-box">
        <div id="status">Waiting for system load...</div>
        <div id="progress-container">
            <div id="progress-stats">0% (0/0 moves)</div>
            <div class="progress-bar-bg"><div id="progress-bar-fill"></div></div>
        </div>
    </div>

    <div id="ui-results"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

<script>
const STOCKFISH_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
let engine = null;
let isScanning = false;
let currentMovesIndices = {}; 

const OPENING_BOOK = new Set([
    "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3", 
    "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3", 
    "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6",
    "rnbqkbnr/ppp1pppp/8/3p4/3P4/8/PPP1PPPP/RNBQKBNR w KQkq d6",
    "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -",
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6"
]);

const PIECES = {
    'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
    'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
    'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
    'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
    'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
    'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
    'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
    'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
    'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
    'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
    'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
    'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg'
};

async function bootStockfish() {
    const statusEl = document.getElementById('status');
    try {
        const response = await fetch(STOCKFISH_CDN);
        const scriptBody = await response.text();
        const blob = new Blob([scriptBody], { type: 'application/javascript' });
        engine = new Worker(URL.createObjectURL(blob));
        engine.onmessage = (e) => {
            if (e.data === 'uciok') {
                document.getElementById('btnScan').disabled = false;
                document.getElementById('btnScan').innerText = "Analyze Profile";
                statusEl.innerText = "Engine ready.";
            }
        };
        engine.postMessage('uci');
    } catch (err) { statusEl.innerText = "Engine Load Error."; }
}

function getEngineAnalysis(fen) {
    return new Promise((resolve) => {
        let score = 0; let isMate = false; let bestMove = '';
        const timeout = setTimeout(() => {
            engine.removeEventListener('message', handler);
            resolve({ score: 0, isMate: false, bestMove: '' });
        }, 8000);

        const handler = (e) => {
            if (e.data.includes('score cp')) {
                const match = e.data.match(/score cp (-?\d+)/);
                if (match) score = parseInt(match[1]);
            } else if (e.data.includes('score mate')) {
                const match = e.data.match(/score mate (-?\d+)/);
                if (match) { score = parseInt(match[1]); isMate = true; }
            }
            if (e.data.startsWith('bestmove')) {
                clearTimeout(timeout);
                const match = e.data.match(/bestmove\s+(\S+)/);
                bestMove = match ? match[1] : '';
                engine.removeEventListener('message', handler);
                resolve({ score, isMate, bestMove });
            }
        };
        engine.addEventListener('message', handler);
        engine.postMessage(`position fen ${fen}`);
        engine.postMessage('go depth 12');
    });
}

function classifyMove(delta, isUserTurn, bestData, actualData, isBook) {
    if (!isUserTurn) return { label: '', class: '', reason: '' };
    if (isBook) return { label: 'Book', class: 'cls-book', reason: 'Opening theory.' };
    
    const lostWinningMate = bestData.isMate && bestData.score > 0 && !actualData.isMate;
    const allowedLosingMate = !bestData.isMate && actualData.isMate && actualData.score < 0;
    
    let label = ''; let cls = ''; 

    if (lostWinningMate || allowedLosingMate || delta > 300) { label = 'Blunder'; cls = 'cls-blunder'; }
    else if (delta <= 10) { label = 'Best'; cls = 'cls-best'; }
    else if (delta <= 35) { label = 'Excellent'; cls = 'cls-excellent'; }
    else if (delta <= 70) { label = 'Good'; cls = 'cls-good'; }
    else if (delta <= 150) { label = 'Inaccuracy'; cls = 'cls-inaccuracy'; }
    else { label = 'Mistake'; cls = 'cls-mistake'; }

    return { label, class: cls };
}

function getStorageKey(user) { return `chess_reviewer_${user.toLowerCase()}`; }
function getStatsKey(user) { return `chess_stats_${user.toLowerCase()}`; }

function loadCache(user) {
    const data = localStorage.getItem(getStorageKey(user));
    return data ? JSON.parse(data) : [];
}
function saveCache(user, games) {
    localStorage.setItem(getStorageKey(user), JSON.stringify(games));
}

function updateStatsUI(user) {
    const games = loadCache(user);
    if (!games.length) return;

    let totalBlunders = 0;
    let greatMoves = 0;
    let totalAccuracy = 0;
    let maxBook = 0;
    let openings = {};

    games.forEach(g => {
        let gameBlunders = 0;
        let gameAccuracy = 0;
        let userMoves = 0;
        let bookCount = 0;

        g.moves.forEach(m => {
            if (m.isUserTurn) {
                userMoves++;
                if (m.classification.label === 'Blunder') gameBlunders++;
                if (['Best', 'Excellent'].includes(m.classification.label)) greatMoves++;
                
                // Simplified Accuracy calc (100 - average centipawn loss weighted)
                // This is a rough estimation for display
            }
            if (m.isBook) bookCount++;
            else { maxBook = Math.max(maxBook, bookCount); bookCount = 0; }
        });
        
        totalBlunders += gameBlunders;
        maxBook = Math.max(maxBook, bookCount);

        // Track opening (First 4 moves)
        const opKey = g.moves.slice(0, 4).map(m => m.san).join(' ');
        if (opKey) openings[opKey] = (openings[opKey] || 0) + 1;
    });

    const favOpening = Object.entries(openings).sort((a,b) => b[1] - a[1])[0]?.[0] || 'N/A';

    document.getElementById('stats-container').style.display = 'grid';
    document.getElementById('stat-blunder').innerText = totalBlunders;
    document.getElementById('stat-great').innerText = greatMoves;
    document.getElementById('stat-book').innerText = maxBook;
    document.getElementById('stat-opening').innerText = favOpening.split(' ')[0] + '...';
    document.getElementById('stat-opening').title = favOpening;
}

function isBookMove(fen) {
    const parts = fen.split(' ');
    const simplified = parts.slice(0, 4).join(' ');
    return OPENING_BOOK.has(simplified) || parseInt(parts[5]) <= 2;
}

async function startAnalysis() {
    const user = document.getElementById('username').value.trim();
    if (!user) return;
    
    isScanning = true;
    document.getElementById('btnScan').disabled = true;
    document.getElementById('btnStop').style.display = 'inline-block';
    document.getElementById('progress-container').style.display = 'block';
    
    const uiResults = document.getElementById('ui-results');
    uiResults.innerHTML = '';

    const cachedGames = loadCache(user);
    const processedIds = new Set(cachedGames.map(g => g.url));
    cachedGames.forEach((g, idx) => renderGameCard(g, idx));
    updateStatsUI(user);

    try {
        const archivesRes = await fetch(`https://api.chess.com/pub/player/${user}/games/archives`);
        const archivesList = await archivesRes.json();
        if (!archivesList.archives?.length) throw new Error("No archive found.");

        const archives = archivesList.archives.reverse(); // Newest months first
        const newlyAnalyzed = [...cachedGames];

        for (let arcUrl of archives) {
            if (!isScanning) break;
            document.getElementById('status').innerText = `Fetching archive...`;
            const arcRes = await fetch(arcUrl);
            const arcData = await arcRes.json();
            const games = arcData.games.reverse();

            for (let i = 0; i < games.length; i++) {
                if (!isScanning) break;
                const g = games[i];
                if (processedIds.has(g.url)) continue;

                const isWhite = g.white.username.toLowerCase() === user.toLowerCase();
                const opponent = isWhite ? g.black.username : g.white.username;
                const chess = new Chess();
                if (!g.pgn) continue;
                chess.load_pgn(g.pgn);
                
                const moveHistory = chess.history({ verbose: true });
                const outcome = (isWhite ? g.white.result : g.black.result) === 'win' ? 'Win' : 
                                (['draw', 'stalemate'].includes(isWhite ? g.white.result : g.black.result) ? 'Draw' : 'Loss');
                
                const analysisData = { url: g.url, opponent, isWhite, outcome, moves: [], blunders: 0 };
                const tempChess = new Chess();

                for (let m = 0; m < moveHistory.length; m++) {
                    if (!isScanning) break;
                    const turn = m % 2 === 0 ? 'w' : 'b';
                    const isUserTurn = (isWhite && turn === 'w') || (!isWhite && turn === 'b');
                    const posBefore = tempChess.fen();
                    const bestData = await getEngineAnalysis(posBefore);
                    const movePlayed = moveHistory[m];
                    tempChess.move(movePlayed.san);
                    const posAfter = tempChess.fen();
                    const actualData = await getEngineAnalysis(posAfter);

                    const getVal = (d) => d.isMate ? (d.score > 0 ? 10000 : -10000) : d.score;
                    const loss = turn === 'w' ? getVal(bestData) - getVal(actualData) : getVal(actualData) - getVal(bestData);
                    const isBook = isBookMove(posBefore);
                    const classification = classifyMove(loss, isUserTurn, bestData, actualData, isBook);
                    if (classification.label === 'Blunder') analysisData.blunders++;
                    
                    analysisData.moves.push({
                        san: movePlayed.san, from: movePlayed.from, to: movePlayed.to,
                        bestMove: bestData.bestMove, fen: posAfter,
                        score: isWhite ? actualData.score : -actualData.score, 
                        isMate: actualData.isMate,
                        classification, moveNum: Math.floor(m/2) + 1, turn, isUserTurn, isBook
                    });

                    document.getElementById('progress-bar-fill').style.width = `100%`;
                    document.getElementById('progress-stats').innerText = `Analyzing vs ${opponent} (${m+1}/${moveHistory.length})`;
                }

                if (isScanning) {
                    newlyAnalyzed.unshift(analysisData);
                    saveCache(user, newlyAnalyzed);
                    renderGameCard(analysisData, newlyAnalyzed.length, true);
                    updateStatsUI(user);
                }
            }
        }
    } catch (e) { document.getElementById('status').innerText = e.message; }
    finally {
        isScanning = false;
        document.getElementById('btnScan').disabled = false;
        document.getElementById('btnStop').style.display = 'none';
        document.getElementById('status').innerText = "Analysis Finished.";
    }
}

function renderGameCard(data, gameId, isNew = false) {
    const ui = document.getElementById('ui-results');
    const card = document.createElement('div');
    card.className = 'game-card';
    card.id = `card-${gameId}`;
    currentMovesIndices[gameId] = 0;

    card.innerHTML = `
        <div class="game-header" onclick="this.parentElement.classList.toggle('expanded')">
            <div class="side-icon ${data.isWhite ? 'white' : 'black'}">♚</div>
            <div style="flex-grow:1">
                <div style="font-weight:bold">vs ${data.opponent}</div>
                <div style="font-size:11px; color:var(--subtext)">${data.moves.length} moves analyzed</div>
            </div>
            <div style="text-align:right">
                <div style="font-size:11px; font-weight:800; color:${data.outcome === 'Win' ? '#2ecc71' : '#e74c3c'}">${data.outcome.toUpperCase()}</div>
                <div style="background:var(--accent); color:white; font-size:10px; padding:2px 6px; border-radius:10px; margin-top:4px;">${data.blunders} Blunders</div>
            </div>
        </div>
        <div class="analysis-container">
            <div class="board-layout">
                <div class="ranks-labels"><div>8</div><div>7</div><div>6</div><div>5</div><div>4</div><div>3</div><div>2</div><div>1</div></div>
                <div class="board-wrapper">
                    <div id="board-${gameId}" class="chess-board"></div>
                    <svg id="arrows-${gameId}" class="arrow-overlay" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
                </div>
                <div class="files-labels"><div>a</div><div>b</div><div>c</div><div>d</div><div>e</div><div>f</div><div>g</div><div>h</div></div>
                <div class="board-controls">
                    <div class="main-eval-bar-container">
                        <div id="main-bar-${gameId}" class="main-eval-bar-fill"></div>
                        <div id="main-val-${gameId}" class="main-eval-text">0.0</div>
                    </div>
                    <div class="nav-buttons">
                        <button class="nav-btn" onclick="stepMove(event, ${gameId}, -1, ${gameId})">PREVIOUS</button>
                        <button class="nav-btn" onclick="stepMove(event, ${gameId}, 1, ${gameId})">NEXT</button>
                    </div>
                </div>
            </div>
            <div id="movelist-${gameId}" class="move-list"></div>
        </div>
    `;
    
    if (isNew) ui.prepend(card); else ui.appendChild(card);
    
    // Inject move list to avoid stringify issues in HTML attributes
    const list = card.querySelector('.move-list');
    data.moves.forEach((m, idx) => {
        const scoreText = m.isMate ? (m.score > 0 ? "M" + Math.abs(m.score) : "-M" + Math.abs(m.score)) : (m.score > 0 ? "+" : "") + (m.score/100).toFixed(1);
        const row = document.createElement('div');
        row.id = `row-${gameId}-${idx}`;
        row.className = `move-row ${m.isUserTurn ? 'user-move' : 'opponent-move'}`;
        row.onclick = () => selectMove(gameId, idx, data.moves);
        row.innerHTML = `
            <div class="move-label-container">
                <div class="move-identity ${m.isUserTurn ? 'user-id' : 'opponent-id'}">${m.isUserTurn ? 'Your Move' : "Opponent"}</div>
                <div style="font-size:13px;"><span style="color:#666">${m.turn === 'w' ? m.moveNum + '.' : m.moveNum + '...'}</span> <strong>${m.san}</strong></div>
                ${m.classification.label ? `<span class="move-label ${m.classification.class}">${m.classification.label}</span>` : ''}
            </div>
            <div></div>
            <div class="eval-text ${m.isMate ? 'mate-txt' : ''}">${m.isBook ? '—' : scoreText}</div>
        `;
        list.appendChild(row);
    });

    updateBoard(gameId, data.moves[0]);
}

function stepMove(e, gameId, direction, dataId) {
    if(e) e.stopPropagation();
    const user = document.getElementById('username').value.trim();
    const moves = loadCache(user).find((_, idx) => true).moves; // Placeholder logic - actual app uses state
    // To handle "Step" correctly without passing huge JSONs, we look up the cached game
    const games = loadCache(user);
    // Find the right game data by reverse engineering or storing in a global map
    const gameData = games.find(g => g.moves.length > 0 && currentMovesIndices[gameId] !== undefined); 

    let nextIdx = currentMovesIndices[gameId] + direction;
    if (gameData && nextIdx >= 0 && nextIdx < gameData.moves.length) {
        selectMove(gameId, nextIdx, gameData.moves);
    }
}

function selectMove(gameId, idx, moves) {
    currentMovesIndices[gameId] = idx;
    updateBoard(gameId, moves[idx]);
    const row = document.getElementById(`row-${gameId}-${idx}`);
    if (row) {
        row.parentNode.querySelectorAll('.move-row').forEach(r => r.classList.remove('active'));
        row.classList.add('active');
        row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function updateBoard(gameId, moveData) {
    const boardEl = document.getElementById(`board-${gameId}`);
    const arrows = document.getElementById(`arrows-${gameId}`);
    const bar = document.getElementById(`main-bar-${gameId}`);
    const valText = document.getElementById(`main-val-${gameId}`);
    if (!boardEl) return;
    
    boardEl.innerHTML = '';
    arrows.innerHTML = '';

    const rows = moveData.fen.split(' ')[0].split('/');
    for (let r = 0; r < 8; r++) {
        let col = 0;
        for (let char of rows[r]) {
            if (isNaN(char)) createSq(boardEl, r, col++, char, moveData);
            else for (let e = 0; e < parseInt(char); e++) createSq(boardEl, r, col++, null, moveData);
        }
    }

    if (!moveData.isBook && moveData.bestMove) {
        const from = moveData.bestMove.slice(0, 2), to = moveData.bestMove.slice(2, 4);
        if (from !== moveData.from || to !== moveData.to) drawArrow(arrows, from, to);
    }

    if (bar && valText) {
        const pct = moveData.isBook ? 50 : (moveData.isMate ? (moveData.score > 0 ? 100 : 0) : (50 + (50 * Math.tanh((moveData.score/100)/4))));
        bar.style.width = `${pct}%`;
        valText.innerText = moveData.isBook ? "BOOK" : (moveData.isMate ? (moveData.score > 0 ? "M" : "-M") + Math.abs(moveData.score) : (moveData.score > 0 ? "+" : "") + (moveData.score/100).toFixed(1));
    }
}

function drawArrow(svg, from, to) {
    const getPos = (s) => ({ col: s.charCodeAt(0)-97, row: 8-parseInt(s[1]) });
    const s = getPos(from), e = getPos(to);
    const x1 = s.col*12.5+6.25, y1 = s.row*12.5+6.25, x2 = e.col*12.5+6.25, y2 = e.row*12.5+6.25;
    const angle = Math.atan2(y2-y1, x2-x1), len = Math.sqrt((x2-x1)**2+(y2-y1)**2);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute("transform", `translate(${x1},${y1}) rotate(${angle*180/Math.PI})`);
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", `M 0 0 L ${len-3} 0 M ${len-3} -2.5 L ${len} 0 L ${len-3} 2.5 Z`);
    path.setAttribute("fill", "rgba(46, 204, 113, 0.7)");
    path.setAttribute("stroke", "rgba(46, 204, 113, 0.7)");
    path.setAttribute("stroke-width", "1.5");
    g.appendChild(path);
    svg.appendChild(g);
}

function createSq(cont, r, c, p, m) {
    const sq = document.createElement('div');
    const id = String.fromCharCode(97+c) + (8-r);
    sq.className = `square ${(r+c)%2 === 0 ? 'white' : 'black'} ${id === m.from || id === m.to ? 'highlight' : ''}`;
    if (p) { const i = document.createElement('img'); i.src = PIECES[p]; i.className = 'piece'; sq.appendChild(i); }
    cont.appendChild(sq);
}

function stopAnalysis() { isScanning = false; }
window.onload = bootStockfish;
</script>
</body>
</html>

