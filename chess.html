<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grandmaster Blunder Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: #e0e0e0; padding: 20px; }
        .container { max-width: 900px; margin: auto; }
        .controls { background: #2d2d2d; padding: 20px; border-radius: 10px; display: flex; gap: 10px; margin-bottom: 20px; border: 1px solid #444; }
        input { flex: 1; padding: 12px; border-radius: 5px; border: 1px solid #555; background: #111; color: #fff; }
        button { padding: 12px 24px; border-radius: 5px; border: none; background: #007bff; color: white; cursor: pointer; font-weight: bold; }
        button:disabled { background: #555; cursor: not-allowed; }
        .status { margin-bottom: 10px; font-style: italic; color: #aaa; }
        .game-card { background: #2d2d2d; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 5px solid #007bff; }
        .blunder-tag { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; margin-right: 5px; font-weight: bold; }
        .tag-fork { background: #ff4757; color: white; }
        .tag-pin { background: #ffa502; color: white; }
        .tag-hanging { background: #57606f; color: white; }
        .json-view { background: #000; color: #00ff00; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>

<div class="container">
    <h1>♟️ Grandmaster Blunder Engine</h1>
    <div class="controls">
        <input type="text" id="username" placeholder="Chess.com Username">
        <button id="btnScan" onclick="startAnalysis()" disabled>Loading Engine...</button>
    </div>
    
    <div id="status" class="status">Initializing Stockfish...</div>
    <div id="ui-results"></div>
    <h3>Full Data Object:</h3>
    <pre id="json-output" class="json-view">{}</pre>
</div>

<script>
// --- ENGINE SETUP ---
const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 99 };
let engine = null;
let isReady = false;

function initEngine() {
    try {
        engine = new Worker(STOCKFISH_URL);
        engine.onmessage = (e) => {
            if (e.data === 'uciok') {
                isReady = true;
                document.getElementById('btnScan').disabled = false;
                document.getElementById('btnScan').innerText = "Analyze Last 10 Games";
                document.getElementById('status').innerText = "Engine Ready.";
            }
        };
        engine.postMessage('uci');
    } catch (err) {
        document.getElementById('status').innerText = "Worker Error. Try hosting locally or checking CDN.";
    }
}

function getEval(fen) {
    return new Promise((resolve) => {
        const listener = (e) => {
            if (e.data.startsWith('info depth 12')) {
                const cp = e.data.match(/score cp (-?\d+)/);
                const pv = e.data.match(/pv (\w+)/);
                if (cp && pv) {
                    engine.removeEventListener('message', listener);
                    resolve({ cp: parseInt(cp[1]), bestMove: pv[1] });
                }
            }
        };
        engine.addEventListener('message', listener);
        engine.postMessage(`position fen ${fen}`);
        engine.postMessage('go depth 12');
    });
}

// --- TACTICAL ENGINE ---
function analyzeTactics(game, moveUci, responseUci) {
    const tags = [];
    const testBoard = new Chess(game.fen());
    const move = testBoard.move(responseUci, { sloppy: true });
    if (!move) return tags;

    // 1. Hanging Piece Check
    if (move.captured) {
        tags.push({ type: 'HANGING', desc: `Left ${move.captured.toUpperCase()} on ${move.to}` });
    }

    // 2. Fork Detection
    let attacked = 0;
    const squares = ['a1','b1','c1','d1','e1','f1','g1','h1','a2','b2','c2','d2','e2','f2','g2','h2','a3','b3','c3','d3','e3','f3','g3','h3','a4','b4','c4','d4','e4','f4','g4','h4','a5','b5','c5','d5','e5','f5','g5','h5','a6','b6','c6','d6','e6','f6','g6','h6','a7','b7','c7','d7','e7','f7','g7','h7','a8','b8','c8','d8','e8','f8','g8','h8'];
    squares.forEach(sq => {
        const p = testBoard.get(sq);
        if (p && p.color !== testBoard.turn() && testBoard.attacked(sq, testBoard.turn())) {
            attacked++;
        }
    });
    if (attacked >= 2) tags.push({ type: 'FORK', desc: 'Allowed a fork' });

    // 3. Pin Detection
    if (move.captured) {
        const pieceSquare = move.to;
        const color = testBoard.turn() === 'w' ? 'b' : 'w';
        testBoard.remove(pieceSquare); 
        // If removing the piece reveals a check or attack on higher value piece
        if (testBoard.in_check()) tags.push({ type: 'PIN', desc: 'Piece was pinned to King' });
    }

    return tags;
}

// --- APP LOGIC ---
async function startAnalysis() {
    const user = document.getElementById('username').value;
    if (!user) return alert("Enter a username");
    
    document.getElementById('btnScan').disabled = true;
    const status = document.getElementById('status');
    const results = [];
    
    try {
        status.innerText = "Fetching games...";
        const arcRes = await fetch(`https://api.chess.com/pub/player/${user}/games/archives`);
        const { archives } = await arcRes.json();
        const gRes = await fetch(archives[archives.length - 1]);
        const { games } = await gRes.json();
        const last10 = games.slice(-10);

        for (const [i, g] of last10.entries()) {
            status.innerText = `Analyzing game ${i+1}/10...`;
            const chess = new Chess();
            chess.load_pgn(g.pgn);
            const history = chess.history({ verbose: true });
            const blunders = [];
            const simBoard = new Chess();

            for (const m of history) {
                const isUser = (m.color === 'w' && g.white.username.toLowerCase() === user.toLowerCase()) || 
                               (m.color === 'b' && g.black.username.toLowerCase() === user.toLowerCase());
                
                const before = await getEval(simBoard.fen());
                simBoard.move(m);
                const after = await getEval(simBoard.fen());

                const scoreBefore = m.color === 'w' ? before.cp : -before.cp;
                const scoreAfter = m.color === 'w' ? after.cp : -after.cp;
                const drop = scoreBefore - scoreAfter;

                if (isUser && drop > 150) {
                    blunders.push({
                        move: m.san,
                        drop: drop,
                        tags: analyzeTactics(simBoard, m.san, after.bestMove)
                    });
                }
            }
            results.push({ opponent: g.white.username === user ? g.black.username : g.white.username, blunders });
            renderGame(results[results.length-1]);
        }
        document.getElementById('json-output').innerText = JSON.stringify(results, null, 2);
        status.innerText = "Done!";
    } catch (e) {
        status.innerText = "Error: " + e.message;
    } finally {
        document.getElementById('btnScan').disabled = false;
    }
}

function renderGame(data) {
    const div = document.createElement('div');
    div.className = 'game-card';
    div.innerHTML = `<strong>Game vs ${data.opponent}</strong><br>` + 
        data.blunders.map(b => `<div>Move ${b.move}: ${b.tags.map(t => `<span class="blunder-tag tag-${t.type.toLowerCase()}">${t.type}</span>`).join('')}</div>`).join('');
    document.getElementById('ui-results').appendChild(div);
}

initEngine();
</script>
</body>
</html>
